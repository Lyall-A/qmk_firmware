import { _ as _export_sfc, c as createElementBlock, o as openBlock, a8 as createStaticVNode } from "./chunks/framework.Clpp4x2N.js";
const __pageData = JSON.parse('{"title":"SN32F2XX Driver","description":"","frontmatter":{},"headers":[],"relativePath":"drivers/sn32f2xx.md","filePath":"drivers/sn32f2xx.md"}');
const _sfc_main = { name: "drivers/sn32f2xx.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h1 id="sn32f2xx-driver" tabindex="-1">SN32F2XX Driver <a class="header-anchor" href="#sn32f2xx-driver" aria-label="Permalink to &quot;SN32F2XX Driver {#sn32f2xx-driver}&quot;">​</a></h1><p>This driver provides support for PWM driven RGB LED matrix on the Sonix SN32F2xx series of chips.</p><h2 id="hardware-configuration" tabindex="-1">Hardware Configuration <a class="header-anchor" href="#hardware-configuration" aria-label="Permalink to &quot;Hardware Configuration {#hardware-configuration}&quot;">​</a></h2><p>The most common way to configure the LED wiring is on a <code>3 ( R/B/G channel sinks) x 1 ( actively driven PWM line)</code> matrix, controlled by transistors through GPIO pins.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>    Default configuration example</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    COLS key / led</span></span>\n<span class="line"><span>    SS8050 transistors NPN driven low</span></span>\n<span class="line"><span>    base      - GPIO</span></span>\n<span class="line"><span>    collector - LED Col pins</span></span>\n<span class="line"><span>    emitter   - VDD</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    VDD     GPIO</span></span>\n<span class="line"><span>    (E)     (B)</span></span>\n<span class="line"><span>     |  PNP  |</span></span>\n<span class="line"><span>     |_______|</span></span>\n<span class="line"><span>         |</span></span>\n<span class="line"><span>         |</span></span>\n<span class="line"><span>        (C)</span></span>\n<span class="line"><span>        LED</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>    ROWS RGB</span></span>\n<span class="line"><span>    SS8550 transistors PNP driven high</span></span>\n<span class="line"><span>    base      - GPIO</span></span>\n<span class="line"><span>    collector - LED RGB row pins</span></span>\n<span class="line"><span>    emitter   - GND</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>        LED</span></span>\n<span class="line"><span>        (C)</span></span>\n<span class="line"><span>         |</span></span>\n<span class="line"><span>         |</span></span>\n<span class="line"><span>      _______</span></span>\n<span class="line"><span>     |  NPN  |</span></span>\n<span class="line"><span>     |       |</span></span>\n<span class="line"><span>    (B)     (E)</span></span>\n<span class="line"><span>    GPIO    GND</span></span></code></pre></div><p>The driver has provisions to either use hardware PWM, or bitbang if the pins configured do not have available PWM mode.</p><h2 id="usage" tabindex="-1">Usage <a class="header-anchor" href="#usage" aria-label="Permalink to &quot;Usage {#usage}&quot;">​</a></h2><p>In most cases, the SN32F2XX driver code is automatically included if you are using the <a href="./../features/rgb_matrix">RGB Matrix</a> feature with the <code>sn32f2xx</code> driver set, and you would use that API instead.</p><p>However, if you need to use the driver standalone, add the following to your <code>rules.mk</code>:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">COMMON_VPATH += </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">$(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DRIVER_PATH</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/led</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">SRC += sn32f2xx.c</span></span></code></pre></div><p>You can then call the SN32F2XX API by including <code>sn32f2xx.h</code> in your code.</p><h2 id="basic-configuration" tabindex="-1">Basic Configuration <a class="header-anchor" href="#basic-configuration" aria-label="Permalink to &quot;Basic Configuration {#basic-configuration}&quot;">​</a></h2><p>Add the following to your <code>config.h</code>:</p><table><thead><tr><th>Define</th><th>Default</th><th>Description</th></tr></thead><tbody><tr><td><code>SN32F2XX_RGB_MATRIX_ROW_PINS</code></td><td><em>Not defined</em></td><td>The GPIO pins connected to the RGB sink triplets on every row of the LEDs in the matrix<sup>1</sup></td></tr><tr><td><code>SN32F2XX_RGB_MATRIX_COL_PINS</code></td><td><code>MATRIX_COL_PINS</code></td><td>The GPIO pins connected to the LED columns on every column of the LEDs in the matrix<sup>2</sup></td></tr><tr><td><code>SN32F2XX_RGB_MATRIX_COLS</code></td><td><code>MATRIX_COLS</code></td><td>Number of LED columns in the LED matrix</td></tr><tr><td><code>SN32F2XX_RGB_MATRIX_ROWS</code></td><td><code>MATRIX_ROWS</code></td><td>Number of LED rows in the LED matrix</td></tr><tr><td><code>SN32F2XX_RGB_MATRIX_ROW_CHANNELS</code></td><td><code>3</code></td><td>The number of available color channels for each LED</td></tr><tr><td><code>SN32F2XX_PWM_OUTPUT_ACTIVE_LEVEL</code></td><td><code>SN32F2XX_PWM_OUTPUT_ACTIVE_LOW</code></td><td>The logic level that enables PWM output. Depends on transistor controlling PWM</td></tr><tr><td><code>SN32F2XX_RGB_OUTPUT_ACTIVE_LEVEL</code></td><td><code>SN32F2XX_RGB_OUTPUT_ACTIVE_HIGH</code></td><td>The logic level that enables RGB output. Depends on transistor controlling RGB sinks</td></tr><tr><td><code>SN32F2XX_PWM_DIRECTION</code></td><td><code>DIODE_DIRECTION</code></td><td>The scanning logic direction for the LED matrix</td></tr><tr><td><code>SN32F2XX_PWM_CONTROL</code></td><td><code>HARDWARE_PWM</code></td><td>Toggles hardware or software control for the PWM</td></tr><tr><td><code>SN32F2XX_LED_OUTPUT_LUMINOSITY_R</code></td><td><code>1</code></td><td>Luminosity correction factor for the Red channel</td></tr><tr><td><code>SN32F2XX_LED_OUTPUT_LUMINOSITY_G</code></td><td><code>1</code></td><td>Luminosity correction factor for the Green channel</td></tr><tr><td><code>SN32F2XX_LED_OUTPUT_LUMINOSITY_B</code></td><td><code>1</code></td><td>Luminosity correction factor for the Blue channel</td></tr></tbody></table><p>Notes:</p><ol><li>The currently supported RGB byte order is <code>R/B/G</code> for each row triplet. Example config for 3 rows <code>(R0, B0, G0, R1, B1, G1, R2, B2, G2)</code></li><li>If not user defined, it assumes shared matrix</li></ol><h2 id="shared-matrix" tabindex="-1">Shared Matrix <a class="header-anchor" href="#shared-matrix" aria-label="Permalink to &quot;Shared Matrix {#shared-matrix}&quot;">​</a></h2><p>The driver can share LED matrix wiring with the key matrix, specifically columns. It takes over the key scanning routines and carefully times it to avoid key chatter and LED artifacts. Please note that key scan cycles are affected, although the result is a snappy key scan.</p><h2 id="arm-configuration" tabindex="-1">ChibiOS/ARM Configuration <a class="header-anchor" href="#arm-configuration" aria-label="Permalink to &quot;ChibiOS/ARM Configuration {#arm-configuration}&quot;">​</a></h2><p>The following defines apply only to ARM devices:</p><h3 id="arm-pwm-driver" tabindex="-1">PWM Driver <a class="header-anchor" href="#arm-pwm-driver" aria-label="Permalink to &quot;PWM Driver {#arm-pwm-driver}&quot;">​</a></h3><p>Depending on the ChibiOS board configuration, you may need to enable PWM at the keyboard level. For SN32, this would look like:</p><p><code>halconf.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HAL_USE_PWM</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span></code></pre></div><p><code>mcuconf.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#undef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SN32_PWM_USE_CT16B1</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SN32_PWM_USE_CT16B1</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span></code></pre></div><p>and additionally configure the CT peripheral</p><p><code>mcuconf.h</code>:</p><div class="language-c vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">c</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#undef</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SN32_PWM_NO_RESET</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">#define</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> SN32_PWM_NO_RESET</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TRUE</span></span></code></pre></div><p>The driver uses the CT timer to handle PWM, even if software PWM is selected.</p><h2 id="api" tabindex="-1">API <a class="header-anchor" href="#api" aria-label="Permalink to &quot;API {#api}&quot;">​</a></h2><h3 id="api-sn32f2xx-set-color" tabindex="-1"><code>void sn32f2xx_set_color(int index, uint8_t red, uint8_t green, uint8_t blue)</code> <a class="header-anchor" href="#api-sn32f2xx-set-color" aria-label="Permalink to &quot;`void sn32f2xx_set_color(int index, uint8_t red, uint8_t green, uint8_t blue)` {#api-sn32f2xx-set-color}&quot;">​</a></h3><p>Set the color of a single LED (RGB driver only).</p><h4 id="api-sn32f2xx-set-color-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-sn32f2xx-set-color-arguments" aria-label="Permalink to &quot;Arguments {#api-sn32f2xx-set-color-arguments}&quot;">​</a></h4><ul><li><code>int index</code> The LED index.</li><li><code>uint8_t red</code> The red value to set.</li><li><code>uint8_t green</code> The green value to set.</li><li><code>uint8_t blue</code> The blue value to set.</li></ul><hr><h3 id="api-sn32f2xx-set-color-all" tabindex="-1"><code>void sn32f2xx_set_color_all(uint8_t red, uint8_t green, uint8_t blue)</code> <a class="header-anchor" href="#api-sn32f2xx-set-color-all" aria-label="Permalink to &quot;`void sn32f2xx_set_color_all(uint8_t red, uint8_t green, uint8_t blue)` {#api-sn32f2xx-set-color-all}&quot;">​</a></h3><p>Set the color of all LEDs (RGB driver only).</p><h4 id="api-sn32f2xx-set-color-all-arguments" tabindex="-1">Arguments <a class="header-anchor" href="#api-sn32f2xx-set-color-all-arguments" aria-label="Permalink to &quot;Arguments {#api-sn32f2xx-set-color-all-arguments}&quot;">​</a></h4><ul><li><code>uint8_t red</code> The red value to set.</li><li><code>uint8_t green</code> The green value to set.</li><li><code>uint8_t blue</code> The blue value to set.</li></ul>', 40);
const _hoisted_41 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_41);
}
const sn32f2xx = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  sn32f2xx as default
};
